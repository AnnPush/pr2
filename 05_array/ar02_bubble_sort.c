/*Метод пузырьковой сортировки:
#include <stdio.h>
#define SIZE 10
int main(void)
{
	int a[SIZE] = {2, 6, 4, 8, 10, 12, 89, 68, 45, 37};
    puts("Data items in original order");
	for (size_t i = 0; i < SIZE; ++i)
	{
		printf("%4d", a[i]);
	}
	for (unsigned int pass = 1; pass < SIZE; ++pass)
	{
		for (size_t i =0; i < SIZE - 1; ++i)
		{
			if(a[i] > a[i + 1]
			{
				int hold = a[i];
				a[i] = a[i + 1];
				a[i + 1] = hold;
			}
		}
	}
	puts("\nData items in ascending order");
	for (size_t i = 0; i < SIZE; ++i)
	{
		printf("%4d", a[i]);
	}
    
	puts("");
}
Представленный вариант является неэффективным для больших массивов.
Нужно сделать такие изменения для повышения эффективности пузырьковой сортировки:
а) После первого прохода самое большое число гарантированно находится в элементе 
массива с наибольшим индексом: после второго прохода «на место» попадают два самых 
больших числа и так далее. Измените пузырьковую сортировку так, чтобы вместо проведения
девяти сравнений в каждом проходе нужно было делать восемь сравнений на втором проходе,
семь на третьем и т. д.
b) Данные в массиве могут уже находиться в надлежащем порядке или порядке, близком
к нему, так зачем делать девять проходов, если будет достаточно меньшего количества?
Измените сортировку так, чтобы в конце каждого прохода проверялось, делались ли 
перестановки. Если перестановок не было, то данные уже находятся в нужном порядке, 
так что программа должна завершиться. Если перестановки были, то необходим, 
по крайней мере, еще один проход.
*/

#include <stdio.h>
#define SIZE 10

int main(void)
{
	int a[SIZE] = {2, 6, 4, 8, 10, 12, 89, 68, 45, 37};
	int swapped = 1;

    puts("Data items in original order");

        //вывести исходный массив
	for (size_t i = 0; i < SIZE; ++i)
	{
		printf("%4d", a[i]);
	}

        //пузырьковая сортировка
	
        //цикл для контроля числа проходов
	for (unsigned int pass = 1; pass < SIZE; ++pass)
	{
	        //если перестановки были, делаем еще один проход
	        if(swapped == 1)
		{
		       swapped = 0;
		       
	               //цикл для контроля числа сравнений на данном проходе
		       for (size_t i =0; i < SIZE - pass; ++i)
		       {
		               //сравнить соседние элементы и обменять их,
			       //если первый элемент больше второго
			       if(a[i] > a[i + 1])
			       {
				       int hold = a[i];
				       a[i] = a[i + 1];
				       a[i + 1] = hold;
				       swapped = 1;
			       }
		        }
		}
		//если перестановок нет, то программа завершает работу
		else
	        {
	                break;
	        }
		
		puts("");
		
		//показать, какие сравнения проводились
		for(size_t i = 0; i < SIZE - pass; ++i)
	        {
		        printf("%4d", a[i]);
	        }
		
	        puts("");
	}

	puts("\nData items in ascending order");

        //вывести сортированный массив
	for (size_t i = 0; i < SIZE; ++i)
	{
		printf("%4d", a[i]);
	}
    
	puts("");
}
