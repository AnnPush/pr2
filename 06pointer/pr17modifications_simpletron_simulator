#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

#define MEMSIZE 1000 //память Симплетрона
#define MAXWORD 7 //максимальная длина слова

/* Операции ввода/вывода */
#define READ   10 //вводит слово с терминала в указанное место памяти
#define WRITE  11 //выводит на терминал слово из указанного адреса памяти
#define NEWLINE 12 //вывод новой строки
#define SREAD 13  //ввод строк
#define SWRITE 14  //вывод строк

/* Операции загрузки/Выгрузки */
#define LOAD  20 //помещает в аккумулятор слово из указанного адреса памяти
#define STORE 21 //выгружает слово из аккумулятора по указанному адресу памяти

/* Арифметические операции */
#define ADD      30 //выполняет сложение слова в аккумуляторе и слова из указанного места в памяти (результат операции остается в аккумуляторе)
#define SUBTRACT  31 //вычитает из слова в аккумуляторе слово из указанного места в памяти (результат операции остается в аккумуляторе)
#define DIVIDE   32 //выполняет деление слова в аккумуляторе на слово из указанного места в памяти (результат операции остается в аккумуляторе)
#define MULTIPLY 33 //вычисляет произведение слова в аккумуляторе и слова из указанного места в памяти (результат операции остается в аккумуляторе)
#define REST     34 //значение по модулю
#define POWER    35 //степень числа

/* Операции передачи управления */
#define BRANCH     40 //переход к указанному адресу памяти
#define BRANCHNEG  41 //переход к указанному адресу памяти, если в аккумуляторе находится отрицательное число 
#define BRANCHZERO 42 //переход к указанному адресу памяти, если в аккумуляторе находится ноль
#define HALT       43 //останов, выполняется при завершении программой своей работы

int checkword(int word, int size); //проверка слова
void dump(float acc, int icounter, float mem[]); //вывод содержимого каждого регистра(дамп памяти)
int r_htoi(const char string[]); //из шестнадцатеричного в десятичное
char * p_itoh(int num, char str[], int z); //из десятичного в шестнадцатеричное

int main(void)
{
   char s_mem[MAXWORD] = { 0 }; //массив символов
   
   //модель памяти в качестве одномерного массива из 1000 элементов и аккумулятор
   float memory[MEMSIZE] = { 0 }, accumulator = 0;

   int operationCode = 0; //переменная для хранения кода текущей исполняемой команды, т. е. левых двух цифр слова команды
   int instructionRegister = 0; //для хранения исполняемой команды
   int operand = 0; //в переменной хранится адрес операнда текущей исполняемой команды(две правые цифры командного слова)
   int i, j, k, err = 0;
   float t_val = 0, f_tmp;


    printf("*** Симплетрон приветствует вас! ***\n"
	  "*** Пожалуйста, введите вашу программу по одной команде ***\n"
	  "*** (или слову данных) за раз. Я буду выводить в качестве ***\n"
	  "*** подсказки текущий адрес и знак вопроса (?).  ***\n"
	  "*** Введенное вами слово будет размещено по указанному адресу. ***\n"
	  "*** Для прекращения ввода программы введите число -99999 ***\n");

    for(i = 0; i < MEMSIZE; i++) 
    {
        while(1) 
	    {
		    //ввести команды программы
            printf("%.2d ?? ", i);
            scanf("%s", s_mem);

	        memory[i] = r_htoi(s_mem);

	        if(memory[i] == -999999) 
			{
	            memory[i] = 0;
	            i = MEMSIZE; //для завершения цикла
	            break;
	        }

	        if(s_mem[0] != '+')
			{
	            printf("*** Ошибка: %s\n", s_mem);
	            printf("*** Используйте '+' или выйти.\n");
	            continue;
	        }

	        if( checkword((int)memory[i], MEMSIZE) ) 
			{
	            printf("*** Ошибка: +%.0f\n"
		        "*** Повторите введение команды или выход.\n", memory[i]);
	        }
	        else
	            break;

        } /* end while */
    } /* end for (i) */

    printf("*** Загрузка программы завершена ***\n"
	       "*** Начинаю выполнение программы ***\n");
	
    for(i = 0; i < MEMSIZE; i++) 
	{
        instructionRegister = (int)memory[i];

        operationCode = instructionRegister / (instructionRegister <= 9999 ? 100 : 1000);
        operand = instructionRegister % (instructionRegister <= 9999 ? 100 : 1000);

        /* это необходимо, потому что после switch()
         'i' счетчик увеличивается на 1. */
        if(operationCode >= BRANCH)
            --operand;

        switch(operationCode)
		{
	        case READ:
	            printf("\nВвести слово: ");
                scanf("%f", &memory[operand]);
	        break;
			
	        case WRITE:
	            printf("\nРазмещение в памяти: %.2d\nWord: %.2f\n",
	            operand, memory[operand]);
	        break;
			
	        case NEWLINE:
	            printf("\n");
	        break;
			
	        case SREAD:
	            /* If this instruction is used then HALT is required */
	            printf("\nInsert a string: ");
	            scanf("%s", s_mem);

	            if(strlen(s_mem) > 3) 
				{
	                err = 3;
	                break;
				}
				
	            for(j = 0; (unsigned)j < strlen(s_mem); j++)
                {
	                if((int)s_mem[j] > 99)
					{
		                err = 4;
		                t_val = j;
		                break;
	                }
	            }
	            memory[operand] = 0;

	            for(j = strlen(s_mem), k = 1; j >= 0; k *= 100, j--)
                    memory[operand] += s_mem[j] * k;

                for(t_val = 0.1, k = 1; k < memory[operand]; t_val *= 0.10, k *= 10) ;
	                t_val /= 0.10;

	            memory[operand] *= t_val;
	            memory[operand] += strlen(s_mem);

	        break;
			
	        case SWRITE:
	            printf("\nMemory location: %.0f\nWord: ", memory[operand]);
	            for(j = (int)memory[operand], t_val = 100; j ; t_val *= 100, j--) 
				{ 
	               f_tmp = memory[operand] * t_val;
	               k = (int)f_tmp % 100;
	               printf("%c", k);
	            }
	            printf("\n");
	        break;
			
	        case LOAD:
	            accumulator = memory[operand];
	        break;
			
	        case STORE:
	            memory[operand] = accumulator;
	        break;

	        case ADD:
	            accumulator += memory[operand];
	        break;
			
	        case SUBTRACT:
	            accumulator -= memory[operand];
            break;
			
	        case DIVIDE:
	            if( !memory[operand] )
	                err = 2;
	            else
	                accumulator /= memory[operand];
	        break;
			
	        case MULTIPLY:
	            accumulator *= memory[operand];
	        break;
			
	        case REST:
	            accumulator = (int)accumulator % (int)memory[operand];
	        break;

	        case POWER:
	            accumulator = pow(accumulator, memory[operand]);
	        break;

	        case BRANCH:
	            i = operand;
	        break;
			
	        case BRANCHNEG:
	            if(accumulator < 0)
	                i = operand;
	        break;
			
	        case BRANCHZERO:
	            if(!accumulator)
	                i = operand;
            break;

	 case HALT:
	    i = MEMSIZE; /* terminate the for loop */
	    /* dump(accumulator, i, memory); */

            break;
	 case 0:
	    break;

	 default:
	    printf("*** unknown error: %d\n", instructionRegister);
	    dump(accumulator, i, memory);
	    printf("\nAre'nt you using HALT (+4300)?\n");
	    exit(-1);
      }

      if(accumulator > MEMSIZE * MEMSIZE - 1 ||
         accumulator < MEMSIZE * -MEMSIZE + 1)
         err = 1;

      if(err) { /* Error messages manager */
	 printf("\n*** ");
	 switch(err) {
	    case 1:
               printf("Out of the accumulator limit"); 
	       break;
	    case 2:
	       printf("Attempt to divide by zero");
	       break;
	    case 3:
	       printf("You can put max 3 numbers for memory location");
	       break;
	    case 4:
	       printf("This ASCII code is too long: %d (%c)",
		  s_mem[(int)t_val], s_mem[(int)t_val]);
	 }

	 printf(" ***\n");
	 
         printf("*** Simpletron execution abnormally terminated ***\n");
         dump(accumulator, i, memory);
         exit(-1);
      }

   } /* end for (i) */

   /* dump(accumulator, i, memory); */
   printf("\n*** Simpletron execution terminated ***\n");

   return 0;
} /* E0F main */

/* проверка слова на корректность */
int checkword(int word, int size)
{
   if( word < 0 || word >= MEMSIZE * MEMSIZE ||
       word % (word <= 9999 ? 100 : 1000) >= size ) {
      return 1;
   }

   switch(word / (word <= 9999 ? 100 : 1000)) {
      case READ:
      case WRITE:
      case NEWLINE:
      case SREAD:
      case SWRITE:
      case LOAD:
      case STORE:
      case ADD:
      case SUBTRACT:
      case DIVIDE:
      case MULTIPLY:
      case REST:
      case POWER:
      case BRANCH:
      case BRANCHNEG:
      case BRANCHZERO:
      case HALT:
      case 0:
         break;
      default:
	 return 1;

   } /* end switch (word) */

   return 0;

} /* eof checkword() */

/* Show a dump of the current memory state */
void dump(float acc, int icounter, float mem[])
{
   int i, j;
   char string[6] = { 0 };

   printf("\nREGISTERS:\n");

   printf("accumulator\t\t%c%s\n", acc < 0 ? '-' : '+', p_itoh(acc, string, 4));
   printf("instructionCounter\t%s\n", p_itoh(icounter, string, 2));

   printf("instructionRegister\t%c%s\n", mem[icounter] < 0 ? '-' : '+',
      p_itoh(mem[icounter] < 0 ? -mem[icounter] : mem[icounter], string, 4));

   printf("operationCode\t\t%s\n", p_itoh(mem[icounter] / 100, string, 2));
   printf("operand\t\t\t%s\n", p_itoh((int)mem[icounter] % 100, string, 2));

   printf("\nMEMORY:\n");

   /* Print the header */
   printf("%3c", ' ');
   for(i = 0; i < 10; i++)
      printf("%5d ", i);
   printf("\n");

   for(i = 0; i < MEMSIZE; i += 10) {
      printf("%.3d", i);
      for(j = i; j < i+10; j++) {
	 printf(" %c%s", mem[j] < 0 ? '-' : '+',
	   p_itoh(mem[j] < 0 ? -mem[j] : mem[j], string, 4));
      }
      printf("\n");
   }

} /* eof dump() */

int r_htoi(const char string[])
{
   int i, num = 0, n = 1;
   char s[1] = { 0 };

   for(i = strlen(string) - 1; i >= 0; i--) {
      if(string[i] >= 'A' && string[i] <= 'F')
         n *= 10;

      n *= 10;
   }

   n /= 10;

   for(i = 0; i < 7; n /= 10, i++) {

      if(string[i] >= 'A' && string[i] <= 'F') {
         num += 1 * n;
         n /= 10;
      }

      switch(string[i])
      {  
         case 'A':
	 case 'a':
            /* 0 */
            break;
         case 'B':
	 case 'b':
            num += 1 * n;
            break;
         case 'C':
	 case 'c':
            num += 2 * n;
            break;
         case 'D':
	 case 'd':
            num += 3 * n;
            break;
         case 'E':
	 case 'e':
            num += 4 * n;
            break;
         case 'F':
	 case 'f':
            num += 5 * n;
            break;
         default:
            *s = string[i];
            if(string[0] == '-')
               num -= atoi(s) * n;
            else
               num += atoi(s) * n;
      } /* end switch */

   }

   return num;
}

char * p_itoh(int num, char str[], int z)
{
   int i, idx = 0;

   if(num > 0) {
      if(num <= 9) i = 1;
      else if(num <= 99) i = 10;
      else if(num <= 999) i = 100;
      else if(num <= 9999) i = 1000;
      else if(num <= 99999) i = 10000;
      else {
	 printf("error in p_itoh(): unknown range: %d\n", num);
	    printf("\nAre'nt you using HALT (+4300)?\n");
	 exit(-1);
      }
   }
   else if(!num) {
      for(i = 0; i < (int)sizeof(str); i++) {
	 if(i < z) str[i] = '0';
	 else str[i] = ' ';
      }
      return str;
   }
   else {
      printf("Negative numbers are not allowed!\n");
      return 0;
   }

   for( ; i ; idx++, i /= 10) {

      if( (num / i % 10) == 1 ) {

         i /= 10;
	 if(!i) break;
         switch(num / i % 10) {
	    case 0:
	       str[idx] = 'A';
	       break;
	    case 1:
	       str[idx] = 'B';
	       break;
	    case 2:
	       str[idx] = 'C';
	       break;
	    case 3:
	       str[idx] = 'D';
	       break;
	    case 4:
	       str[idx] = 'E';
	       break;
            case 5:
	       str[idx] = 'F';
	       break;
	    default:
	       str[idx] = (char)(num / i % 10) + '0';
	       i *= 10;
	 }
      }

      else {
	 str[idx] = (char)(num / i % 10) + '0';
      }
   } /* end for (i) */

   return str;
}
